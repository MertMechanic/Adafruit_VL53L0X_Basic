


    // pixels.begin(); // This initializes the NeoPixel library.(in setup!)
    

    // VL53L0X_RangingMeasurementData_t measure;

    // Serial.print("Reading a measurement... ");
    // lox.rangingTest(&measure, false); // pass in 'true' to get debug data printout!

    // if (measure.RangeStatus != 4)
    // { // phase failures have incorrect data

    //     Serial.print("Distance (mm): ");
    //     Serial.println(measure.RangeMilliMeter);
    //     if (measure.RangeStatus <= 1)
    //     {
    //         counterOfFailedMessures++;
    //     }
    //     else
    //     {
    //         counterOfFailedMessures = 0;
    //     }
    // }
    // else
    // {
    //     Serial.println(" out of range ");
    //     resetled();
    //     pixels.show();
    // }

    // if (maxFailedMeasure == counterOfFailedMessures)
    // {
    //     lox.begin();
    //     lox.configSensor(Adafruit_VL53L0X::VL53L0X_SENSE_LONG_RANGE);
    // }
    // int divValue = 55;
    // int dimmvalue = 0;
    // resetled();
    // dimmvalue = measure.RangeMilliMeter / 255;
    // if (measure.RangeMilliMeter < 666)
    // {
    //     if (measure.RangeMilliMeter < divValue)
    //     {
    //         ledOn = 1;
    //         dimmvalue = (255 / ledOn * measure.RangeMilliMeter);
    //     }
    //     else if (measure.RangeMilliMeter < divValue * 2)
    //     {
    //         ledOn = 2;
    //         dimmvalue = (255 / ledOn * measure.RangeMilliMeter);
    //     }
    //     else if (measure.RangeMilliMeter < divValue * 3)
    //     {
    //         ledOn = 3;
    //         dimmvalue = (255 / ledOn * measure.RangeMilliMeter);
    //     }
    //     else if (measure.RangeMilliMeter < divValue * 4)
    //     {
    //         ledOn = 4;
    //         dimmvalue = (255 / ledOn * measure.RangeMilliMeter);
    //     }
    //     else if (measure.RangeMilliMeter < divValue * 5)
    //     {
    //         ledOn = 5;
    //         dimmvalue = (255 / ledOn * measure.RangeMilliMeter);
    //     }
    //     else if (measure.RangeMilliMeter < divValue * 6)
    //     {
    //         ledOn = 6;
    //         dimmvalue = (255 / ledOn * measure.RangeMilliMeter);
    //     }
    //     else if (measure.RangeMilliMeter < divValue * 7)
    //     {
    //         ledOn = 7;
    //         dimmvalue = (255 / ledOn * measure.RangeMilliMeter);
    //     }
    //     else if (measure.RangeMilliMeter < divValue * 8)
    //     {
    //         ledOn = 8;
    //         dimmvalue = (255 / ledOn * measure.RangeMilliMeter);
    //     }
    //     else if (measure.RangeMilliMeter < divValue * 9)
    //     {
    //         ledOn = 9;
    //         dimmvalue = (255 / ledOn * measure.RangeMilliMeter);
    //     }
    //     else if (measure.RangeMilliMeter < divValue * 10)
    //     {
    //         ledOn = 10;
    //         dimmvalue = (255 / ledOn * measure.RangeMilliMeter);
    //     }
    //     else if (measure.RangeMilliMeter < divValue * 11)
    //     {
    //         ledOn = 11;
    //         dimmvalue = (255 / ledOn * measure.RangeMilliMeter);
    //     }
    //     else if (measure.RangeMilliMeter < divValue * 12)
    //     {
    //         ledOn = 12;
    //         dimmvalue = (255 / ledOn * measure.RangeMilliMeter);
    //     }

    //     for (int i = 0; i < ledOn - 1; i++)
    //     {
    //         // pixels.Color takes RGB values, from 0,0,0 up to 255,255,255
    //         pixels.setPixelColor(i, pixels.Color(255, 0, 0)); // Moderately bright green color.
    //     }
    //     pixels.setPixelColor(ledOn - 1, pixels.Color(dimmvalue, 0, 0));

    //     pixels.show(); // This sends the updated pixel color to the hardware.
    // }
    // else if (measure.RangeMilliMeter > 666 && measure.RangeMilliMeter < (666 * 2))
    // {
    //     int divValueGreen = divValue + 666;
    //     if (measure.RangeMilliMeter < divValueGreen)
    //         ledOn = 1;
    //     else if (measure.RangeMilliMeter < divValueGreen * 2)
    //         ledOn = 2;
    //     else if (measure.RangeMilliMeter < divValueGreen * 3)
    //         ledOn = 3;
    //     else if (measure.RangeMilliMeter < divValueGreen * 4)
    //         ledOn = 4;
    //     else if (measure.RangeMilliMeter < divValueGreen * 5)
    //         ledOn = 5;
    //     else if (measure.RangeMilliMeter < divValueGreen * 6)
    //         ledOn = 6;
    //     else if (measure.RangeMilliMeter < divValueGreen * 7)
    //         ledOn = 7;
    //     else if (measure.RangeMilliMeter < divValueGreen * 8)
    //         ledOn = 8;
    //     else if (measure.RangeMilliMeter < divValueGreen * 9)
    //         ledOn = 9;
    //     else if (measure.RangeMilliMeter < divValueGreen * 10)
    //         ledOn = 10;
    //     else if (measure.RangeMilliMeter < divValueGreen * 11)
    //         ledOn = 11;
    //     else if (measure.RangeMilliMeter < divValueGreen * 12)
    //         ledOn = 12;

    //     for (int i = 0; i < ledOn - 1; i++)
    //     {
    //         // pixels.Color takes RGB values, from 0,0,0 up to 255,255,255
    //         pixels.setPixelColor(i, pixels.Color(0, 255, 0)); // Moderately bright green color.
    //     }
    //     pixels.setPixelColor(ledOn - 1, pixels.Color(0, dimmvalue, 0));
    //     pixels.show(); // This sends the updated pixel color to the hardware.
    // }
    // else if (measure.RangeMilliMeter > (666 * 2) && measure.RangeMilliMeter < (666 * 3))
    // {
    //     int divValueBlue = divValue + 2 + 666;
    //     if (measure.RangeMilliMeter < divValueBlue)
    //         ledOn = 1;
    //     else if (measure.RangeMilliMeter < divValueBlue * 2)
    //         ledOn = 2;
    //     else if (measure.RangeMilliMeter < divValueBlue * 3)
    //         ledOn = 3;
    //     else if (measure.RangeMilliMeter < divValueBlue * 4)
    //         ledOn = 4;
    //     else if (measure.RangeMilliMeter < divValueBlue * 5)
    //         ledOn = 5;
    //     else if (measure.RangeMilliMeter < divValueBlue * 6)
    //         ledOn = 6;
    //     else if (measure.RangeMilliMeter < divValueBlue * 7)
    //         ledOn = 7;
    //     else if (measure.RangeMilliMeter < divValueBlue * 8)
    //         ledOn = 8;
    //     else if (measure.RangeMilliMeter < divValueBlue * 9)
    //         ledOn = 9;
    //     else if (measure.RangeMilliMeter < divValueBlue * 10)
    //         ledOn = 10;
    //     else if (measure.RangeMilliMeter < divValueBlue * 11)
    //         ledOn = 11;
    //     else if (measure.RangeMilliMeter < divValueBlue * 12)
    //         ledOn = 12;
    //     for (int i = 0; i < ledOn - 1; i++)
    //     {
    //         // pixels.Color takes RGB values, from 0,0,0 up to 255,255,255
    //         pixels.setPixelColor(i, pixels.Color(0, 0, 255)); // Moderately bright green color.
    //     }
    //     pixels.setPixelColor(ledOn - 1, pixels.Color(0, 0, dimmvalue));
    //     pixels.show(); // This sends the updated pixel color to the hardware.
    // }
    delay(100);

    //     for(int i=0;i<NUMPIXELS;i++)
    //   {
    //     // pixels.Color takes RGB values, from 0,0,0 up to 255,255,255
    //     pixels.setPixelColor(i, pixels.Color(255,0,0)); // Moderately bright green color.
    //     pixels.show(); // This sends the updated pixel color to the hardware.
    //     delay(delayval); // Delay for a period of time (in milliseconds).
    //   }

    //   for(int i=0;i<NUMPIXELS;i++)
    //   {
    //     // pixels.Color takes RGB values, from 0,0,0 up to 255,255,255
    //     pixels.setPixelColor(i, pixels.Color(0,255,0)); // Moderately bright green color.
    //     pixels.show(); // This sends the updated pixel color to the hardware.
    //     delay(delayval); // Delay for a period of time (in milliseconds).
    //   }

    //   for(int i=0;i<NUMPIXELS;i++)
    //   {
    //     // pixels.Color takes RGB values, from 0,0,0 up to 255,255,255
    //     pixels.setPixelColor(i, pixels.Color(0,0,255)); // Moderately bright green color.
    //     pixels.show(); // This sends the updated pixel color to the hardware.
    //     delay(delayval); // Delay for a period of time (in milliseconds).
    //   }